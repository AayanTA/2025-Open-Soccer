import cv2
import numpy as np
import time
from picamera2 import Picamera2
import math
from gpiozero import Button

# GPIO setup
button = Button(2)
running = False
was_running = False

def toggle_run():
    global running
    running = not running
    state = "‚ñ∂Ô∏è Resumed" if running else "‚è∏Ô∏è Paused"
    print(f"üîò Button pressed: {state}")

button.when_pressed = toggle_run

# Initialize Picamera2
picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(main={"format": "RGB888", "size": (640, 480)}))
picam2.start()

# =====================
# GOAL COLOURS (BGR)
# =====================
cyan_rgb = np.array([0, 255, 255])    # Adjust after testing
yellow_rgb = np.array([255, 255, 0])  # Adjust after testing
color_threshold = 70

# Memory setup (per goal)
frame_center = (320, 240)
persist_time = 2.0
prev_gray = None

goal_data = {
    "cyan": {"rgb": cyan_rgb, "last_pos": None, "last_angle": None, "last_seen": 0},
    "yellow": {"rgb": yellow_rgb, "last_pos": None, "last_angle": None, "last_seen": 0}
}

print("üü° Waiting for button press to start...")

def process_goal(frame_rgb, mask_motion, goal_name, goal_info):
    """Detect and update one goal."""
    diff = np.linalg.norm(frame_rgb - goal_info["rgb"], axis=2)
    mask = (diff < color_threshold).astype(np.uint8) * 255

    if mask_motion is not None:
        mask = cv2.bitwise_and(mask, mask_motion)

    kernel = np.ones((5, 5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    best_contour = None
    best_score = float('inf')

    for contour in contours:
        area = cv2.contourArea(contour)
        if area < 50:  # larger min area for goals
            continue

        x, y, w, h = cv2.boundingRect(contour)
        center = (int(x + w / 2), int(y + h / 2))

        # Edge weighting
        edge_weight = 1.2 if (x <= 5 or y <= 5 or x + w >= 635 or y + h >= 475) else 1.0

        mask_roi = np.zeros_like(mask)
        cv2.drawContours(mask_roi, [contour], -1, 255, -1)
        mean_color = np.array(cv2.mean(frame_rgb, mask=mask_roi)[:3])
        color_dist = np.linalg.norm(mean_color - goal_info["rgb"]) * edge_weight

        if color_dist < best_score:
            best_score = color_dist
            best_contour = contour

    if best_contour is not None and best_score < color_threshold:
        x, y, w, h = cv2.boundingRect(best_contour)
        center = (int(x + w / 2), int(y + h / 2))
        goal_info["last_pos"] = center
        goal_info["last_seen"] = time.time()

        dx = center[0] - frame_center[0]
        dy = frame_center[1] - center[1]
        angle = (math.degrees(math.atan2(dx, dy)) + 360) % 360
        goal_info["last_angle"] = angle

        cv2.rectangle(frame_rgb, (x, y), (x + w, y + h), (0, 255, 0) if goal_name == "cyan" else (0, 255, 255), 2)
        cv2.putText(frame_rgb, f"{goal_name.capitalize()} Goal: {int(angle)} deg", (center[0] + 10, center[1]),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

        print(f"{goal_name.capitalize()} Goal Position: {center}, Angle: {int(angle)}¬∞")

    elif goal_info["last_pos"] and time.time() - goal_info["last_seen"] < persist_time:
        cv2.circle(frame_rgb, goal_info["last_pos"], 10, (200, 200, 200), 2)
        cv2.putText(frame_rgb, f"Last {goal_name.capitalize()} Angle: {int(goal_info['last_angle'])} deg",
                    (goal_info["last_pos"][0] + 10, goal_info["last_pos"][1]),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (200, 200, 200), 2)
        print(f"Last Seen {goal_name.capitalize()} Goal @ {goal_info['last_pos']}, Angle: {int(goal_info['last_angle'])}¬∞")


while True:
    if not running:
        if was_running:
            print("‚è∏Ô∏è Paused tracking")
            was_running = False
        time.sleep(0.1)
        continue

    if not was_running:
        print("‚ñ∂Ô∏è Started tracking")
        was_running = True

    frame_rgb = picam2.capture_array()

    # Motion filter
    gray = cv2.cvtColor(frame_rgb, cv2.COLOR_RGB2GRAY)
    motion_mask = None
    if prev_gray is not None:
        frame_diff = cv2.absdiff(gray, prev_gray)
        _, motion_mask = cv2.threshold(frame_diff, 25, 255, cv2.THRESH_BINARY)
        motion_mask = cv2.dilate(motion_mask, None, iterations=2)
    prev_gray = gray

    # Process both goals
    for goal_name, goal_info in goal_data.items():
        process_goal(frame_rgb, motion_mask, goal_name, goal_info)

    # Save debug frames
    cv2.imwrite("/home/versioncontrol/Desktop/frame_goals.jpg", frame_rgb)

# On exit
cv2.destroyAllWindows()
picam2.stop()
print("‚úÖ Goal tracking ended.")
